---
title: 面向对象之控制反转IOC和依赖注入
date: 2017-05-26 11:38:54
tags: 面向对象
---

> 看标题我最觉得这两个词语很牛逼, 等我讲完你就一下理解了, 这是面向对象中很简单的东西。控制反转也叫ioC, 全称Inverse of Control。

> 控制反转包括依赖注入(DI)和依赖查找(DL), 由于前者的使用更广泛频繁，所以我们大多数情况都认为IoC就是DI。全称分别为: Dependency Injection和Dependency Lookup。

<!-- more -->

- 这个体系中还有个理论的东西叫做Ioc原理，IoC原理也叫做`依赖倒置原理`, 全称Dependency Inversion Principle。

- IoC是一种全新的设计模式。但Gof的23种设计模式中并没有loC是因为控制反转思想成熟较晚。

- JAVA体系中Spring框架的核心就是依赖注入, 其他语言的各种框架也都会用到这种设计模式。

- A类用于查询数据库记录, B类用于连接数据库, 也就是说A依赖于B, 现在我们怎么在A类中书写查询方法呢？

```
为什么不在A中连接数据库？

如果你有一百个A, 你连接一百次, new一百个对象实例出来吗？

这是需要内存和IO开销的！

B类只负责数据库链接, 还要封装工厂单例适配器等各种设计模式)
```

- 单一功能原则是面向对象的基本原则之一, 也是GOF中设计模式的基本原则之一。全称single responsibility principle。

- 我们的A类实体控制内部所有资源对象, 我们在其参数上将B类的引用写上(注入, 类的引用即类的实例化对象), A的内部就可以使用B中的方法, 这就是依赖注入。

- 也就是说, 控制反转是，关于一个对象如何获取他所依赖的对象的引用, 这个责任的反转。这个对象不局限于我上面写的类, 如果是A函数注入B函数, 其实就类似于回调了。

- 什么叫责任的反转？一开始是A对象在内部程序代码中实例化B, 实例化这个操作的责任在内部; 依赖注入后我都在自己的内部当你实例化了, 真正的实例化操作由容器负责, 容器的参数注入实例化对象, 这就是责任反转。

- 依赖注入主要是用来解开对象之间的紧密耦合关系, 解耦是面向对象的基本原则之一。

- 面向对象不得不提接口(Interface), 接口是必须被实现的, new一个接口A的一瞬间, A接口和实现A接口的B类之间, 依赖(耦合)关系就产生了。

- A与B之间有依赖关系。如果想使用接口A的另外一个实现就需要更改代码了。当然我们可以建立一个Factory工厂类来根据条件生成想要的A接口的的具体实现, 这里不解释工厂模式了。

- 工厂模式确实看起来有点用, 但实际上对耦合状态并没有改变,因为这只是在工厂中加判断语句做分流处理。loC则是将依赖问题交给实现类, 可以用于彻底解决依赖问题。

- 在JAVA体系中, loC是依赖于`反射`编程的, 反射就是根据类名来生成对象。

- 反射这种操作比直接new生成对象的效率要低很多, 但是提高了系统的可维护性和灵活性。对于某些生成要求高的对象不联系使用loC。

- JAVA中使用loC反射编程, IDE不方便自动查找重构, 必须开发者手动修改XML配置文件。

- JAVA中的loC容器: Pico Container、Avalon 、Spring、JBoss、HiveMind、EJB等。php中的loC容器可以是任何一个函数或者接口的实现类。

- 不知道各位能理解多少, 整理一下自己的学习笔记。
